def get_pca_combinations(pc_max):
    """
    Generate all unique combinations of PC axes up to pc_max.
    For example, if pc_max=4, generates: (1,2), (2,3), (3,4), (1,3), (2,4), (1,4)
    """
    combinations = []
    for i in range(1, pc_max + 1):
        for j in range(i + 1, pc_max + 1):
            combinations.append((i, j))
    return combinations

# Include rule files
include: "rules/preprocessing.smk"
include: "rules/popdata.smk"
include: "rules/missingness.smk"
include: "rules/faststructure.smk"
include: "rules/admixture.smk"
include: "rules/pcaone.smk"
include: "rules/vcf2pcacluster.smk"
include: "rules/relatedness.smk"
include: "rules/structure.smk"
include: "rules/iqtree.smk"
include: "rules/mapmixture.smk"
include: "rules/population_map.smk"
include: "rules/pixy.smk"
include: "rules/genetic_distances.smk"
include: "rules/mapi.smk"
include: "rules/fineradstructure.smk"
include: "rules/construct.smk"
include: "rules/evaladmix.smk"
include: "rules/amova.smk"

def get_all_targets():
    """
    Build list of target files based on enabled analyses in config.
    This keeps the main Snakefile clean and makes it easy to 
    enable/disable analyses by editing the config file.
    Supports multiple projects, each with their own analyses.
    """
    targets = []
    
    # Iterate through each project
    for project in config["projects"].keys():
        project_config = config["projects"][project]
        analyses = project_config.get("analyses", {})
        params = project_config.get("parameters", {})
        
        # Get project-specific parameters
        k_values = params.get("k_values", [1, 2, 3])
        n_reps = params.get("structure", {}).get("replicates", 1)
        # Default to ["none"] if color_by not specified - will still generate all 6 plots (gray, labeled, missing)
        PCA_groupings = params.get("pca_plot", {}).get("color_by", ["none"])
        pc_max = params.get("pca_plot", {}).get("pc_max", 2)
        pca_combinations = get_pca_combinations(pc_max)
        
        # FastStructure targets
        if analyses.get("faststructure", False):
            targets.extend([
                expand("results/" + project + "/faststructure/" + project + ".faststructure.{k}.meanQ",
                       k=k_values),
                expand("results/" + project + "/faststructure/" + project + ".faststructure.{k}.meanP",
                       k=k_values),
                "results/" + project + "/faststructure/" + project + ".faststructure.chooseK_results.txt"
            ])
            # Only add map plots if popdata is specified
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    expand("results/" + project + "/faststructure/plots/" + project + ".faststructure.K{k}.map.pdf",
                           k=k_values),
                    expand("results/" + project + "/faststructure/plots/" + project + ".faststructure.K{k}.map.rds",
                           k=k_values)
                ])
            # Always add barplots
            targets.extend([
                expand("results/" + project + "/faststructure/plots/" + project + ".faststructure.K{k}.barplot.pdf",
                       k=k_values),
                expand("results/" + project + "/faststructure/plots/" + project + ".faststructure.K{k}.barplot.rds",
                       k=k_values)
            ])
            # Evaladmix targets for fastStructure (only if evaladmix is also enabled)
            if analyses.get("evaladmix", False):
                targets.extend([
                    expand("results/" + project + "/faststructure/evaladmix/" + project + ".faststructure.K{k}.corres.txt",
                           k=k_values),
                    expand("results/" + project + "/faststructure/evaladmix/plots/" + project + ".faststructure.K{k}.evaladmix.pdf",
                           k=k_values),
                    expand("results/" + project + "/faststructure/evaladmix/plots/" + project + ".faststructure.K{k}.evaladmix.rds",
                           k=k_values)
                ])

        # ADMIXTURE targets
        if analyses.get("admixture", False):
            targets.extend([
                expand("results/" + project + "/admixture/" + project + ".biallelic_snps_thinned.{k}.Q",
                       k=k_values),
                expand("results/" + project + "/admixture/" + project + ".biallelic_snps_thinned.{k}.P",
                       k=k_values),
                "results/" + project + "/admixture/" + project + ".admixture.chooseK_results.txt"
            ])
            # Only add map plots if popdata is specified
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    expand("results/" + project + "/admixture/plots/" + project + ".admixture.K{k}.map.pdf",
                           k=k_values),
                    expand("results/" + project + "/admixture/plots/" + project + ".admixture.K{k}.map.rds",
                           k=k_values)
                ])
            # Always add barplots
            targets.extend([
                expand("results/" + project + "/admixture/plots/" + project + ".admixture.K{k}.barplot.pdf",
                       k=k_values),
                expand("results/" + project + "/admixture/plots/" + project + ".admixture.K{k}.barplot.rds",
                       k=k_values)
            ])
            # Evaladmix targets for ADMIXTURE (only if evaladmix is also enabled)
            if analyses.get("evaladmix", False):
                targets.extend([
                    expand("results/" + project + "/admixture/evaladmix/" + project + ".admixture.K{k}.corres.txt",
                           k=k_values),
                    expand("results/" + project + "/admixture/evaladmix/plots/" + project + ".admixture.K{k}.evaladmix.pdf",
                           k=k_values),
                    expand("results/" + project + "/admixture/evaladmix/plots/" + project + ".admixture.K{k}.evaladmix.rds",
                           k=k_values)
                ])

        # STRUCTURE targets
        if analyses.get("structure", False):
            targets.extend([
                expand("results/" + project + "/structure/" + project + ".structure.K{k}.R{r}_f",
                       k=k_values,
                       r=range(1, n_reps + 1)),
                "results/" + project + "/structure/" + project + ".K_aligned.pdf",
                expand("results/" + project + "/structure/" + project + ".structure.K{k}.Qmatrix.txt",
                       k=k_values),
                "results/" + project + "/structure/plots/" + project + ".evanno_plot.pdf",
                "results/" + project + "/structure/plots/" + project + ".evanno_plot.rds"
            ])
            # Only add map plots if popdata is specified
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    expand("results/" + project + "/structure/plots/" + project + ".structure.K{k}.map.pdf",
                           k=k_values),
                    expand("results/" + project + "/structure/plots/" + project + ".structure.K{k}.map.rds",
                           k=k_values)
                ])
            # Always add barplots
            targets.extend([
                expand("results/" + project + "/structure/plots/" + project + ".structure.K{k}.barplot.pdf",
                       k=k_values),
                expand("results/" + project + "/structure/plots/" + project + ".structure.K{k}.barplot.rds",
                       k=k_values)
            ])
            # Evaladmix targets for STRUCTURE (only if evaladmix is also enabled)
            if analyses.get("evaladmix", False):
                targets.extend([
                    expand("results/" + project + "/structure/evaladmix/" + project + ".structure.K{k}.P",
                           k=k_values),
                    expand("results/" + project + "/structure/evaladmix/" + project + ".structure.K{k}.corres.txt",
                           k=k_values),
                    expand("results/" + project + "/structure/evaladmix/plots/" + project + ".structure.K{k}.evaladmix.pdf",
                           k=k_values),
                    expand("results/" + project + "/structure/evaladmix/plots/" + project + ".structure.K{k}.evaladmix.rds",
                           k=k_values)
                ])

        # Missingness targets (always generated)
        # Filtered dataset (before thinning)
        targets.extend([
            "results/" + project + "/missingness_data/filtered/" + project + ".filtered.imiss",
            "results/" + project + "/missingness_data/filtered/" + project + ".filtered.lmiss",
            "results/" + project + "/missingness_data/filtered/plots/" + project + ".filtered.imiss_histogram.pdf",
            "results/" + project + "/missingness_data/filtered/plots/" + project + ".filtered.imiss_histogram.rds",
            "results/" + project + "/missingness_data/filtered/plots/" + project + ".filtered.lmiss_histogram.pdf",
            "results/" + project + "/missingness_data/filtered/plots/" + project + ".filtered.lmiss_histogram.rds"
        ])
        # Thinned dataset (after thinning)
        targets.extend([
            "results/" + project + "/missingness_data/thinned/" + project + ".biallelic_snps_thinned.imiss",
            "results/" + project + "/missingness_data/thinned/" + project + ".biallelic_snps_thinned.lmiss",
            "results/" + project + "/missingness_data/thinned/plots/" + project + ".biallelic_snps_thinned.imiss_histogram.pdf",
            "results/" + project + "/missingness_data/thinned/plots/" + project + ".biallelic_snps_thinned.imiss_histogram.rds",
            "results/" + project + "/missingness_data/thinned/plots/" + project + ".biallelic_snps_thinned.lmiss_histogram.pdf",
            "results/" + project + "/missingness_data/thinned/plots/" + project + ".biallelic_snps_thinned.lmiss_histogram.rds"
        ])
        # PCAone targets (standard)
        if analyses.get("pcaone", False):
            targets.extend([
                "results/" + project + "/pcaone/" + project + ".PCA.eigvecs",
                "results/" + project + "/pcaone/" + project + ".PCA.eigvals"
            ])
            # Always add missing data calculation target (now in missingness_data)
            targets.append("results/" + project + "/missingness_data/thinned/" + project + ".biallelic_snps_thinned.imiss")
            # Add plot targets for each PC combination and color grouping
            for pc1, pc2 in pca_combinations:
                for color_by in PCA_groupings:
                    # Request colored plots (uses color_by)
                    targets.extend([
                        f"results/{project}/pcaone/plots/{project}.PCA-PC{pc1}_PC{pc2}-{color_by}.pdf",
                        f"results/{project}/pcaone/plots/{project}.PCA-PC{pc1}_PC{pc2}-{color_by}.rds"
                    ])
                # Add labeled and missing plots once per PC combination (no color_by)
                targets.extend([
                    f"results/{project}/pcaone/plots/{project}.PCA-PC{pc1}_PC{pc2}-labeled.pdf",
                    f"results/{project}/pcaone/plots/{project}.PCA-PC{pc1}_PC{pc2}-labeled.rds",
                    f"results/{project}/pcaone/plots/{project}.PCA-PC{pc1}_PC{pc2}-missing.pdf",
                    f"results/{project}/pcaone/plots/{project}.PCA-PC{pc1}_PC{pc2}-missing.rds"
                ])
            # Add facet plots (all PC combinations in one plot)
            for color_by in PCA_groupings:
                targets.extend([
                    f"results/{project}/pcaone/plots/{project}.PCA-facet-{color_by}.pdf",
                    f"results/{project}/pcaone/plots/{project}.PCA-facet-{color_by}.rds"
                ])
            targets.extend([
                f"results/{project}/pcaone/plots/{project}.PCA-facet-labeled.pdf",
                f"results/{project}/pcaone/plots/{project}.PCA-facet-labeled.rds",
                f"results/{project}/pcaone/plots/{project}.PCA-facet-missing.pdf",
                f"results/{project}/pcaone/plots/{project}.PCA-facet-missing.rds"
            ])

        # PCAone targets (EMU)
        if analyses.get("pcaone_emu", False):
            targets.extend([
                "results/" + project + "/pcaone_EMU/" + project + ".PCA_EMU.eigvecs",
                "results/" + project + "/pcaone_EMU/" + project + ".PCA_EMU.eigvals"
            ])
            # Always add missing data calculation target (now in missingness_data)
            targets.append("results/" + project + "/missingness_data/thinned/" + project + ".biallelic_snps_thinned.imiss")
            # Add plot targets for each PC combination and color grouping
            for pc1, pc2 in pca_combinations:
                for color_by in PCA_groupings:
                    # Request colored plots (uses color_by)
                    targets.extend([
                        f"results/{project}/pcaone_EMU/plots/{project}.PCA_EMU-PC{pc1}_PC{pc2}-{color_by}.pdf",
                        f"results/{project}/pcaone_EMU/plots/{project}.PCA_EMU-PC{pc1}_PC{pc2}-{color_by}.rds"
                    ])
                # Add labeled and missing plots once per PC combination (no color_by)
                targets.extend([
                    f"results/{project}/pcaone_EMU/plots/{project}.PCA_EMU-PC{pc1}_PC{pc2}-labeled.pdf",
                    f"results/{project}/pcaone_EMU/plots/{project}.PCA_EMU-PC{pc1}_PC{pc2}-labeled.rds",
                    f"results/{project}/pcaone_EMU/plots/{project}.PCA_EMU-PC{pc1}_PC{pc2}-missing.pdf",
                    f"results/{project}/pcaone_EMU/plots/{project}.PCA_EMU-PC{pc1}_PC{pc2}-missing.rds"
                ])

        # PCAone targets (with coverage thresholds)
        if analyses.get("pcaone_miss", False):
            miss_values = params.get("PCAone", {}).get("miss", [0.5])
            targets.extend([
                expand("results/" + project + "/pcaone_miss{miss}/" + project + ".PCA_miss{miss}.eigvecs",
                       miss=miss_values),
                expand("results/" + project + "/pcaone_miss{miss}/" + project + ".PCA_miss{miss}.eigvals",
                       miss=miss_values)
            ])
            # Always add missing data calculation targets for each threshold
            targets.extend([
                expand("results/" + project + "/missingness_data/thinned/" + project + ".biallelic_snps_thinned_miss{miss}.imiss",
                       miss=miss_values)
            ])
            # Add plot targets for each miss value, PC combination, and color grouping
            for miss in miss_values:
                for pc1, pc2 in pca_combinations:
                    for color_by in PCA_groupings:
                        # Request colored plots (uses color_by)
                        targets.extend([
                            f"results/{project}/pcaone_miss{miss}/plots/{project}.PCA_miss{miss}-PC{pc1}_PC{pc2}-{color_by}.pdf",
                            f"results/{project}/pcaone_miss{miss}/plots/{project}.PCA_miss{miss}-PC{pc1}_PC{pc2}-{color_by}.rds"
                        ])
                    # Add labeled and missing plots once per PC combination (no color_by)
                    targets.extend([
                        f"results/{project}/pcaone_miss{miss}/plots/{project}.PCA_miss{miss}-PC{pc1}_PC{pc2}-labeled.pdf",
                        f"results/{project}/pcaone_miss{miss}/plots/{project}.PCA_miss{miss}-PC{pc1}_PC{pc2}-labeled.rds",
                        f"results/{project}/pcaone_miss{miss}/plots/{project}.PCA_miss{miss}-PC{pc1}_PC{pc2}-missing.pdf",
                        f"results/{project}/pcaone_miss{miss}/plots/{project}.PCA_miss{miss}-PC{pc1}_PC{pc2}-missing.rds"
                    ])
        
        # VCF2PCACluster targets
        if analyses.get("vcf2pcacluster", False):
            vcf2pca_params = params.get("vcf2pcacluster", {}).get("SNP_filtering", {})
            miss_values = vcf2pca_params.get("Miss", [0.5])
            maf_values = vcf2pca_params.get("MAF", [0])

            targets.extend(
                expand(
                    "results/" + project + "/vcf2pcacluster_miss{miss}_MAF{MAF}/" + project + ".vcf2pcacluster_miss{miss}_MAF{MAF}.eigenvec",
                    miss=miss_values,
                    MAF=maf_values
                )
            )
            targets.extend(
                expand(
                    "results/" + project + "/vcf2pcacluster_miss{miss}_MAF{MAF}/" + project + ".vcf2pcacluster_miss{miss}_MAF{MAF}.eigenval",
                    miss=miss_values,
                    MAF=maf_values
                )
            )

        # Pixy targets
        if analyses.get("pixy", False):
            targets.extend([
                "results/" + project + "/pixy/" + project + ".pixy_pi-summary.txt",
                "results/" + project + "/pixy/" + project + ".pixy_fst-summary.txt",
                "results/" + project + "/pixy/" + project + ".pixy_dxy-summary.txt",
                # Heatmaps
                "results/" + project + "/pixy/plots/" + project + ".pixy_fst_heatmap.pdf",
                "results/" + project + "/pixy/plots/" + project + ".pixy_fst_heatmap.rds",
                "results/" + project + "/pixy/plots/" + project + ".pixy_dxy_heatmap.pdf",
                "results/" + project + "/pixy/plots/" + project + ".pixy_dxy_heatmap.rds",
                # Plain barplot (no coloring)
                "results/" + project + "/pixy/plots/" + project + ".pixy_pi_barplot-plain.pdf",
                "results/" + project + "/pixy/plots/" + project + ".pixy_pi_barplot-plain.rds"
            ])
            pixy_groupings = params.get("pixy", {}).get("color_by",
                params.get("pca_plot", {}).get("color_by", ["none"]))
            for color_by in pixy_groupings:
                if color_by == "none":
                    continue
                targets.extend([
                    f"results/{project}/pixy/plots/{project}.pixy_pi_barplot-grouped-{color_by}.pdf",
                    f"results/{project}/pixy/plots/{project}.pixy_pi_barplot-grouped-{color_by}.rds",
                ])
                targets.extend([
                    f"results/{project}/pixy/plots/{project}.pixy_pi_barplot-sorted-{color_by}.pdf",
                    f"results/{project}/pixy/plots/{project}.pixy_pi_barplot-sorted-{color_by}.rds",
                ])
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    "results/" + project + "/pixy/plots/" + project + ".pixy_pi_map.pdf",
                    "results/" + project + "/pixy/plots/" + project + ".pixy_pi_map.rds"
                ])

        # Relatedness targets
        if analyses.get("relatedness", False):
            targets.extend([
                "results/" + project + "/relatedness/" + project + ".relatedness",
                "results/" + project + "/relatedness/" + project + ".relatedness2"
            ])
        
        # Relatedness filtering targets
        if params.get("relatedness_filtering", {}).get("enabled", False):
            targets.extend([
                "results/" + project + "/filtered_data/" + project + ".king_table.tsv",
                "results/" + project + "/filtered_data/" + project + ".samples_to_keep.txt",
                "results/" + project + "/population_data/" + project + ".relatedness_filtered_samples.txt",
                # Plain barplot (no grouping)
                "results/" + project + "/population_data/plots/" + project + ".removed_individuals_by_none.pdf",
                "results/" + project + "/population_data/plots/" + project + ".removed_individuals_by_none.rds"
            ])
            # Add barplot targets for each group_by value
            group_by_list = params.get("relatedness_filtering", {}).get("group_by", ["Region"])
            for group_by in group_by_list:
                if group_by != "none" and group_by != "":
                    targets.extend([
                        f"results/{project}/population_data/plots/{project}.removed_individuals_by_{group_by}.pdf",
                        f"results/{project}/population_data/plots/{project}.removed_individuals_by_{group_by}.rds"
                    ])

        # IQtree targets
        if analyses.get("iqtree", False):
            targets.extend([
                "results/" + project + "/iqtree/" + project + ".iqtree.treefile",
                "results/" + project + "/iqtree/" + project + ".iqtree.iqtree",
                "results/" + project + "/iqtree/" + project + ".iqtree.log",
                "results/" + project + "/iqtree/plots/" + project + ".tree_plot.pdf",
                "results/" + project + "/iqtree/plots/" + project + ".tree_plot.rds"
            ])

        # IQtree robust targets
        if analyses.get("iqtree_robust", False):
            targets.extend([
                "results/" + project + "/iqtree_robust/" + project + ".iqtree_robust.treefile",
                "results/" + project + "/iqtree_robust/" + project + ".iqtree_robust.iqtree",
                "results/" + project + "/iqtree_robust/" + project + ".iqtree_robust.log",
                "results/" + project + "/iqtree_robust/plots/" + project + ".tree_plot.pdf",
                "results/" + project + "/iqtree_robust/plots/" + project + ".tree_plot.rds"
            ])

        # Genetic distance targets
        if analyses.get("gen_dist", False):
            targets.extend([
                "results/" + project + "/gen_dist/" + project + ".kosman_distance.tsv",
                "results/" + project + "/gen_dist/" + project + ".euclidean_distance.tsv"
            ])

        # MAPI targets
        if analyses.get("mapi", False):
            # Only run if popdata is specified (required for geographic coordinates)
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    "results/" + project + "/gen_dist/" + project + ".euclidean_distance.tsv",
                    "results/" + project + "/mapi/" + project + ".mapi_results.gpkg",
                    "results/" + project + "/mapi/" + project + ".mapi_euclidean.pdf",
                    "results/" + project + "/mapi/" + project + ".mapi_upper_tails.gpkg",
                    "results/" + project + "/mapi/" + project + ".mapi_lower_tails.gpkg"
                ])
        
        # Population map targets (only run if plot_map is enabled and popdata is available)
        if analyses.get("plot_map", False):
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    "results/" + project + "/population_data/" + project + ".population_map.pdf"
                ])
        
        # Population summary table (always generated if popdata is available)
        popdata = params.get("popdata")
        if popdata and popdata != "NULL" and popdata != "":
            targets.extend([
                "results/" + project + "/population_data/" + project + ".population_summary.txt"
            ])

        # fineRADstructure targets
        if analyses.get("fineradstructure", False):
            targets.extend([
                "results/" + project + "/fineradstructure/" + project + ".input",
                "results/" + project + "/fineradstructure/" + project + "_chunks.out",
                "results/" + project + "/fineradstructure/" + project + "_chunks.mcmc.xml",
                "results/" + project + "/fineradstructure/" + project + "_chunks.mcmcTree.xml",
                "results/" + project + "/fineradstructure/plots/" + project + ".fineradstructure_tree.pdf",
                "results/" + project + "/fineradstructure/plots/" + project + ".fineradstructure_tree.rds"
            ])

        # conStruct targets
        if analyses.get("construct", False):
            # Only run if popdata is specified (required for geographic coordinates)
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    expand("results/" + project + "/construct/" + project + ".construct.K{k}.results.rds",
                           k=k_values),
                    expand("results/" + project + "/construct/" + project + ".construct.K{k}.layer_proportions.txt",
                           k=k_values),
                    expand("results/" + project + "/construct/plots/" + project + ".construct.K{k}.map.pdf",
                           k=k_values),
                    expand("results/" + project + "/construct/plots/" + project + ".construct.K{k}.barplot.pdf",
                           k=k_values)
                ])

        # AMOVA targets
        if analyses.get("amova", False):
            # Only run if popdata is specified (required for stratification)
            popdata = params.get("popdata")
            if popdata and popdata != "NULL" and popdata != "":
                targets.extend([
                    "results/" + project + "/amova/" + project + ".amova_results.txt",
                    "results/" + project + "/amova/plots/" + project + ".amova_variance_components.pdf",
                    "results/" + project + "/amova/plots/" + project + ".amova_variance_components.rds"
                ])

    return targets

# Main target rule
rule all:
    input:
        get_all_targets()
